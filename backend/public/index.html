<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border: 2px solid #fff;
            background-color: #000;
        }
        
        #status {
            margin: 10px 0;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
        }
        
        .connected {
            color: #0f0;
        }
        
        .disconnected {
            color: #f00;
        }
    </style>
</head>
<body>
    <h1>Pong Game</h1>
    <div id="status" class="disconnected">Disconnected</div>
    <div style="margin: 10px 0; color: #ccc;">
        <strong>Controls:</strong><br>
        Player 1 (Left): W/S or Arrow Up/Down<br>
        Player 2 (Right): I/K
    </div>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        
        let ws;
        let gameState = null;
        let lastUpdateTime = 0;
        let interpolationFactor = 0;
        
        function connect() {
            ws = new WebSocket('ws://localhost:3000/game');
            
            ws.onopen = function() {
                status.textContent = 'Connected';
                status.className = 'connected';
                console.log('Connected to game server');
            };
            
            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    
                    if (message.type === 'gameState') {
                        gameState = message.data;
                        lastUpdateTime = performance.now();
                    }
                } catch (err) {
                    console.error('Error parsing message:', err);
                }
            };
            
            ws.onclose = function() {
                status.textContent = 'Disconnected';
                status.className = 'disconnected';
                console.log('Disconnected from game server');
                
                // Try to reconnect after 3 seconds
                setTimeout(connect, 3000);
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }
        
        function drawCapsule(ctx, x1, y1, x2, y2, radius, scale) {
            // Draw capsule (rounded rectangle) using two circles and a rectangle
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) {
                // Just draw a circle if no length
                ctx.beginPath();
                ctx.arc(x1 * scale, y1 * scale, radius * scale, 0, Math.PI * 2);
                ctx.fill();
                return;
            }
            
            // Normalize direction vector
            const nx = dx / length;
            const ny = dy / length;
            
            // Perpendicular vector
            const px = -ny * radius;
            const py = nx * radius;
            
            ctx.beginPath();
            
            // Draw the rectangle part
            ctx.moveTo((x1 + px) * scale, (y1 + py) * scale);
            ctx.lineTo((x2 + px) * scale, (y2 + py) * scale);
            ctx.lineTo((x2 - px) * scale, (y2 - py) * scale);
            ctx.lineTo((x1 - px) * scale, (y1 - py) * scale);
            ctx.closePath();
            ctx.fill();
            
            // Draw the end caps (circles)
            ctx.beginPath();
            ctx.arc(x1 * scale, y1 * scale, radius * scale, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(x2 * scale, y2 * scale, radius * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        function draw() {
            if (!gameState) return;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate scale factor to fit game field in canvas
            const scaleX = canvas.width / gameState.field.width;
            const scaleY = canvas.height / gameState.field.height;
            const scale = Math.min(scaleX, scaleY);
            
            // Draw ball
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(
                gameState.ball.x * scale, 
                gameState.ball.y * scale, 
                gameState.ball.radius * scale, 
                0, Math.PI * 2
            );
            ctx.fill();
            
            // Draw paddle 1 (left) as capsule
            ctx.fillStyle = '#fff';
            if (gameState.paddle1.capsule) {
                const capsule1 = gameState.paddle1.capsule;
                drawCapsule(ctx, capsule1.x1, capsule1.y1, capsule1.x2, capsule1.y2, capsule1.R, scale);
            }
            
            // Draw paddle 2 (right) as capsule
            if (gameState.paddle2.capsule) {
                const capsule2 = gameState.paddle2.capsule;
                drawCapsule(ctx, capsule2.x1, capsule2.y1, capsule2.x2, capsule2.y2, capsule2.R, scale);
            }
            
            // Draw center line
            ctx.strokeStyle = '#fff';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function sendMessage(type, data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type, data }));
            }
        }
        
        // Handle keyboard input
        document.addEventListener('keydown', function(event) {
            switch(event.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    sendMessage('playerInput', { player: 1, action: 'up' });
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    sendMessage('playerInput', { player: 1, action: 'down' });
                    break;
                case 'i':
                case 'I':
                    sendMessage('playerInput', { player: 2, action: 'up' });
                    break;
                case 'k':
                case 'K':
                    sendMessage('playerInput', { player: 2, action: 'down' });
                    break;
            }
        });

        document.addEventListener('keyup', function(event) {
            switch(event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                case 'w':
                case 'W':
                case 's':
                case 'S':
                    sendMessage('playerInput', { player: 1, action: 'stop' });
                    break;
                case 'i':
                case 'I':
                case 'k':
                case 'K':
                    sendMessage('playerInput', { player: 2, action: 'stop' });
                    break;
            }
        });
        
        // Connect to server
        connect();
        
        // Start render loop for smooth animation
        function renderLoop() {
            draw();
            requestAnimationFrame(renderLoop);
        }
        renderLoop();
    </script>
</body>
</html>
